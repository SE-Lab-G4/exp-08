
# گزارش آزمایش هشتم - الگوهای طراحی

## بخش اول – پیاده‌سازی الگوی Adapter

### انتخاب نوع Adapter

در این پروژه از **الگوی Adapter به صورت Object Scope** استفاده شده است. به این معنا که کلاس Adapter (مانند `JungGraphAdapter` و `JGraphTGraphAdapter`) شامل نمونه‌ای از گراف کتابخانه مربوطه است و از طریق ترکیب (Composition) به آن دسترسی دارد، نه از طریق ارث‌بری (Inheritance).

علت استفاده از Object Scope این است که:
- وابستگی به کتابخانه‌ها را کاهش می‌دهد و استقلال بیشتری فراهم می‌کند.
- امکان جایگزینی آسان‌تر کتابخانه بدون تغییر در کلاس‌های پایه را می‌دهد.
- قابلیت تست‌پذیری و نگهداری را افزایش می‌دهد.

از نوع Class Scope استفاده نکردیم، چون نیاز به ارث‌بری از کلاس کتابخانه گراف داشت که ممکن بود محدودیت‌ها و وابستگی بیشتری ایجاد کند.

---

### نحوه پیاده‌سازی الگو

ابتدا یک واسط (`Traverser`) تعریف شد که متد `traverse` را مشخص می‌کند. سپس برای دو الگوریتم DFS و BFS، دو کلاس پیاده‌سازی با استفاده از JUNG ایجاد شدند. در ادامه، کلاس `JungGraphAdapter` طراحی شد که از این کلاس‌ها استفاده می‌کند ولی خودش به صورت واسط گراف رفتار می‌کند. در گام دوم، همین ساختار برای JGraphT هم ایجاد شد و تنها کلاس Adapter تغییر کرد.

---

## بخش دوم – تغییر کتابخانه

###  چگونگی تغییر کتابخانه

در گام دوم، بدون تغییر در interface یا ساختار کلی پروژه، تنها Adapter تغییر یافت. یعنی به جای استفاده از کلاس‌های JUNG در `JungGraphAdapter`، از کلاس‌های JGraphT در `JGraphTGraphAdapter` استفاده شد. این تغییر در پشت صحنه انجام شد و کدهای باقی‌مانده‌ی پروژه نیازی به تغییر نداشتند.

---

### تغییرات ناشی از تغییر کتابخانه از JUNG به JGraphT

- کلاس‌های جدیدی برای DFS و BFS مبتنی بر JGraphT نوشته شد.
- نوع داده‌های گراف از `SparseMultigraph` به `SimpleGraph` تغییر کرد.
- برای دسترسی به همسایه‌ها، منطق استخراج `edgesOf` پیاده‌سازی شد که با ساختار JGraphT سازگار است.
- هیچ تغییری در interface `Traverser` یا ساختار کلاس‌های دیگر داده نشد.

---

## بخش سوم – تحلیل الگوی استراتژی

### سوال ۱ – استفاده از این الگو به چه علتی قابل قبول است؟

الگوی Strategy زمانی استفاده می‌شود که رفتارهای مشابه با پیاده‌سازی‌های مختلف داریم. در این پروژه، الگوریتم‌های مختلف پیمایش گراف (DFS و BFS) به صورت مستقل و قابل تعویض پیاده‌سازی شدند. این الگو باعث جداسازی رفتار از context (مثلاً کلاس Main) می‌شود.

### سوال ۲ – روش تحقق این الگو

ابتدا یک interface به نام `Traverser` طراحی میشود. سپس هر الگوریتم پیمایش (DFS، BFS) به صورت مستقل این واسط را پیاده‌سازی میکند. در نهایت، کلاس‌هایی مانند Adapter و Main تنها به این interface وابسته‌اند و می‌توانند در زمان اجرا هر الگوریتمی را انتخاب کنند.

